CREATING A BLOG DATA MODEL
- in python data and methods make up a python object and classes are a blueprint for bundling data(attributes) and functionality(methods) together. Creating a new class creates a new type of object, allowing me to create instances of that type

- A django model is a source of information about the behaviour of my data. consisting of python class that subclasses django.db.models.Model ,each model maps to a single databasae table( each model we define, we will generate migrations for the models to create corresponding database tables), where each attribute of the class(defined in the models.py) represents a database field. When a model is created, django provides a practical API to query objects in the database easily.
💡 -   '''
   A slug is a short label that contains only letters, numbers, underscores or hyphens. eg, a post like Django Models: a tale of data handling in Django
   will have a slug like this django-models-data-handling.
   '''
- By default, Django adds an auto-incrementing primary key field to each model. The field type for this 
field is specified in each application configuration or globally in the DEFAULT_AUTO_FIELD setting. When 
creating an application with the startapp command, the default value for DEFAULT_AUTO_FIELD is 
BigAutoField. This is a 64-bit integer that automatically increments according to available IDs. If you don’t specify a primary key for your model, Django adds this field automatically. You can also define 
one of the model fields to be the primary key by setting primary_key=True on it.

💡Adding a many-to-one relationship
- here we wish to create a relationship between users and the post that will indicate which user wrote which post. django oomes with an auth framework that handles user accounts, it comes in the django.contrib.auth package and contains the User model.
- We have imported the project’s settings and we have added an author field to the Post model. This 
field defines a many-to-one relationship with the default user model, meaning that each post is written 
by a user, and a user can write any number of posts. For this field, Django will create a foreign key in 
the database using the primary key of the related model.
The on_delete parameter specifies the behavior to adopt when the referenced object is deleted. This 
is not specific to Django; it is a SQL standard. Using CASCADE, you specify that when the referenced 
user is deleted, the database will also delete all related blog posts. You can take a look at all the possible options at https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.
ForeignKey.on_delete.
We use related_name to specify the name of the reverse relationship, from User to Post. This will 
allow us to access related objects easily from a user object by using the user.blog_posts notation. 
We will learn more about this later.
Django comes with different types of fields that you can use to define your models. You can find all 
field types at https://docs.djangoproject.com/en/5.0/ref/models/fields/.
The Post model is now complete, and we can now synchronize it to the database.

💡A migration specifies dependencies on other migrations and operations to perform in the database to synchronize it with model changes.
- after running the makemigrations command to migrate the models to the sqlDB, it creates a file in the migrations directory containing the SQL statements to create the database table for the model defined in the models.py and the definition of the database indsx for the publish field, we can also use the sqlmigrate command to take a look at the SQL code that django will execute in the database to create the table for the model. it takes the migration names and returns their SQL wuthout executing it.
>> python manage.py sqlmigrate myblogsite 0001

CREATING AN ADMIN SITE FOR MODELS
💡 - Now that the Post model is in sync with the database, we can create a simple administration site to 
manage blog posts.
Django comes with a built-in administration interface that is very useful for editing content. The 
Django site is built dynamically by reading the model metadata and providing a production-ready 
interface for editing content. You can use it out of the box, configuring how you want your models to 
be displayed in it.
The django.contrib.admin application is already included in the INSTALLED_APPS setting, so you 
don’t need to add it.
- creating a superuser
>> python manage.py createsuperuser
ADDING MODELS TO THE ADMIN SITE
- When you register a model in the Django administration site, you get a user-friendly interface generated by introspecting your models that allows you to list, edit, create, and delete objects in a simple way.
- rather than using the admin.register(<model>)
we can use a decorator and a class that inherits from (admin.ModelAdmin) with attributes that we can define to customize how the admin app looks like with feilds from our model.

ADDING FACET COUNTS TO FILTERS
Django 5.0 introduces facet filters to the administration site, showcasing facet counts. These counts indicate the number of objects corresponding to each specific filter, making it easier to identify matching objects in the admin changelist view.
LEARM MORE: You can find more information about the Django administration site at https://docs.djangoproject.com/en/5.0/ref/contrib/admin/

💪🏼 Working with QuerySets and managers

Now that we have a fully functional administration site to manage blog posts, it is a good time to learn 
how to read and write content to the database programmatically.
The Django object-relational mapper (ORM) is a powerful database abstraction API that lets you 
create, retrieve, update, and delete objects easily. An ORM allows you to generate SQL queries using 
the object-oriented paradigm of Python. You can think of it as a way to interact with your database in 
a Pythonic fashion instead of writing raw SQL queries.
The ORM maps your models to database tables and provides you with a simple Pythonic interface to 
interact with your database. The ORM generates SQL queries and maps the results to model objects. 
The Django ORM is compatible with MySQL, PostgreSQL, SQLite, Oracle, and MariaDB.
Remember that you can define the database of your project in the DATABASES setting of your project’s 
settings.py file. Django can work with multiple databases at a time, and you can program database 
routers to create custom data routing schemes.
Once you have created your data models, Django gives you a free API to interact with them. You can 
find the model API reference of the official documentation at https://docs.djangoproject.com/
en/5.0/ref/models/.
The Django ORM is based on QuerySets. A QuerySet is a collection of database queries to retrieve objects from your database. You can apply filters to QuerySets to narrow down the query results based 
on given parameters. The QuerySet equates to a SELECT SQL statement and the filters are limiting SQL clauses such as WHERE or LIMIT.  
-  >>> user = User.objects.get(username="prospa")
The get() method allows us to retrieve a single object from the database. This method executes a 
SELECT SQL statement behind the scenes. Note that this method expects a result that matches the 
query. If no results are returned by the database, this method will raise a DoesNotExist exception, 
and if the database returns more than one result, it will raise a MultipleObjectsReturned exception. 
Both exceptions are attributes of the model class that the query is being performed on
- >>> post = Post(title='AnotherPost', slug='anotherslug', body='another post body', author=User)
This object is in memory and not persisted to the database; we created a Python object that can be 
used during runtime but is not saved into the database.
- >>> post.save()
This action performs an INSERT SQL statement behind the scenes.

💡WE CREATED AN OBJECT IN MEMORY FIRST AND PERSISTED IT TO DATABASE, HOWEVER WE CAN CREATE AN OBJECT AND PERSIST TO DATABASE IN A SINGLE OPERATION USING THE CREATE() METHOD AS FOLLOWS
- >>> Post.objects.create(title='One more post',
                        slug='another slug',
                        body='another post body',
                        author=user)

- In certain situations, you might need to fetch an object from the database or create it if it’s absent. 
The get_or_create() method facilitates this by either retrieving an object or creating it if not found. 
This method returns a tuple with the object retrieved and a Boolean indicating whether a new object 
was created. The following code attempts to retrieve a User object with the username user2, and if it 
doesn’t exist, it will create one:
- >>> user, created = User.objects.get_or_create(username='admin2')

💡 performing update:
note that changes made to the model opject are not persisted to the database until the save() method is called. the save() method in this context performs an UPDATE SQL statement under the hood
- >>> post.title('New Title')
- >>> post.save()
💡 retrieving objects
we can retrieve a single object using the get() method, we accessed the object using the Post.object.get(). Each django model has at least one manager and the default manager is called objects. You get a QuerySet using model manager. to retrieve all objects from a table we use the all() method on the default object manager thus
- >>> all_post = Post.objects.all()
Note that this QuerySet has not been executed yet. Django QuerySets are lazy, which means they are only evaluated when they 
are forced to. This behavior makes QuerySets very efficient. If you don’t assign the QuerySet to a variable but, instead, write it directly on the Python shell, the SQL statement of the QuerySet is executed 
because you are forcing it to generate output:
- >>> Post.objects.all()
💡 Filter Objects
To filter a QuerySet, you can use the filter() method of the manager. This method allows you to 
specify the content of a SQL WHERE clause by using field lookups.
- >>> post = Post.objects.filter(title="New Title")
- >>> print(post.query)
The generated WHERE clause performs an exact match on the title column. The ORDER BY clause 
specifies the default order defined in the ordering attribute of the Post model’s Meta options since 
we haven’t provided any specific ordering in the QuerySet. You will learn about ordering in a bit. Note 
that the query attribute is not part of the QuerySet public API.

💡 using field lookups
The QuerySet interface 
provides you with multiple lookup types. Two underscores are used to define the lookup type, with 
the format field__lookup. For example, the following lookup produces an exact match:
>>> Post.objects.filter(id__exact=1)
when no specific lookup type is provided the type defaults to exact. so this below is same as the previous above
>>> Post.objects.filter(id=1)
- iexact = generates a case-sensitive lookup with iexact
>>> Post.objects.filter(title__iexact='Dango containers")
- contains = the contains lookup translates to a SQL lookup using the LIKE operator
>>> Post.objects.filter(title__contains="Containers")
a case sensitive version is also available using icontains
>> Post.objects.filter(title__icontains="Django")
- id__in = retrieves post using a given iterable(a list, tuple, or another QuerySet object)
- gt or lt or lte = greaterthan, lessthan, lessthanorequal lookup. the equivalent SQL clause for this is WHERE ID > 3, < 3, <= 3
>>> Post.objects.filter(id__gt=3), Post.objects.filter(id__lt=3), Post.objects.filter(id__lte=3)
- startswith, endswith or case sensitive istartswith, iendswith
>> Post.objects.filter(title__iendswith="Title"), (.... title__startswith="Docker")
- date = can be performed using the several filters but first <from datetime import date>
>>> Post.objects.filter(publish__year=2025)
>>> Post.objects.filter(publish__date=date(2024, 1, 31))
>>> Post.objects.filter(publish__month=1)
>>> Post.objects.filter(publish__day=1)
>>> Post.objects.filter(publish__date__gt=date(2024, 1, 1))
- lookup related fields, use two underscores like this
>>> Post.objects.filter(author__username="prospa")
>>> Post.objects.filter(publish__year=2024, author__username='admin') #shows how to combine filters

NOTE: The result of a filtered QueySet is another QuerySet object. allowing me the ability to chain QuerySets together. so we can build an equivalent QuerySet of the previous last example like this
>>> Post.objects.filter(publish__year=2025)\
>>>             .filter(author__username='admin')
- ordering objects = the default ordering option is already defined in the models Meta, but we can overide that usinf the order_by() method of the manager for example
>>> Post.objects.order_by('title')
>>> Post.objects.order_by('-title') #ascending order is default, so we use negative sign to imply descending
>>> Post.objects.order_by('author', 'title') #order by multiple fields
>>> Post.objects.order_by('?') #order by random
>>> Post.objects.all()[:5] #limit the QuerySet to a certain numner of results
>>> Post.objects.order_by('?')[0] #retrieve objects of post in random order

- counting objects - the count() method counts the total number of objects matching the QuerySet and returns an integer
>>> Post.objects.filter(id__lt=3).count()
2
- checking for existing objects
usign the exist() method, we check for the existence of a resilt from a QuerySet. it returns a Boolean
>>> Post.objects.filter(title__startswith='Why').exists()

- deleting an object
we can do this by using the delete()method from an object instance
>>> post = Post.objects.get(id=1)
>>> post.delete()

🔥 Complex lookups with Q objects
Field lookups using filter() are joined with a SQL AND operator. For example, filter(field1='foo ', 
field2='bar') will retrieve objects where field1 is foo and field2 is bar. If you need to build more 
complex queries, such as queries with OR statements, you can use Q objects.
A Q object allows you to encapsulate a collection of field lookups. You can compose statements by 
combining Q objects with the & (and), | (or), and ^ (xor) operators. in this case we use | operator to build an OR operator
>>> from django.db.models import Q
>>> starts_who = Q(title__istartswith='who')
>>> starts_why = Q(title__istartswith='why')
>>> Post.objects.filter(starts_who | starts_why)
💪🏼 When QuerySets are evaluated
Creating a QuerySet doesn’t involve any database activity until it is evaluated. QuerySets will usually 
return another unevaluated QuerySet. You can concatenate as many filters as you like to a QuerySet, 
and you will not hit the database until the QuerySet is evaluated. When a QuerySet is evaluated, it 
translates into a SQL query to the database.
QuerySets are only evaluated in the following cases:
• The first time you iterate over them
• When you slice them, for instance, Post.objects.all()[:3]
• When you pickle or cache them
• When you call repr() or len() on them
• When you explicitly call list() on them
• When you test them in a statement, such as bool(), or, and, or if
The QuerySet API reference is located at https://docs.djangoproject.com/en/5.0/ref/models/
querysets/.
You can read more about making queries with the Django ORM at https://docs.djangoproject.com/
en/5.0/topics/db/queries/.
😁 creating model managers
- the default manager for every model is the object manager. it retrieves all the objects in the database. however we can define custom managers for models.
- two ways to add or customize managers for your models, we can add extra manager method to an existing manager or create a new manager by modifying the initial QuerySet that the manager returns. The first method provides me with a QuerySet notation like Post.my_manager.all()
- the second method here, is what we have used in this example, that will allow us to retreive posts using the notation Post.published.all()
