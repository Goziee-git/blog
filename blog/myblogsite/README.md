CREATING A BLOG DATA MODEL
- in python data and methods make up a python object and classes are a blueprint for bundling data(attributes) and functionality(methods) together. Creating a new class creates a new type of object, allowing me to create instances of that type

- A django model is a source of information about the behaviour of my data. consisting of python class that subclasses django.db.models.Model ,each model maps to a single databasae table( each model we define, we will generate migrations for the models to create corresponding database tables), where each attribute of the class(defined in the models.py) represents a database field. When a model is created, django provides a practical API to query objects in the database easily.
💡 -   '''
   A slug is a short label that contains only letters, numbers, underscores or hyphens. eg, a post like Django Models: a tale of data handling in Django
   will have a slug like this django-models-data-handling.
   '''
- By default, Django adds an auto-incrementing primary key field to each model. The field type for this 
field is specified in each application configuration or globally in the DEFAULT_AUTO_FIELD setting. When 
creating an application with the startapp command, the default value for DEFAULT_AUTO_FIELD is 
BigAutoField. This is a 64-bit integer that automatically increments according to available IDs. If you don’t specify a primary key for your model, Django adds this field automatically. You can also define 
one of the model fields to be the primary key by setting primary_key=True on it.

💡Adding a many-to-one relationship
- here we wish to create a relationship between users and the post that will indicate which user wrote which post. django oomes with an auth framework that handles user accounts, it comes in the django.contrib.auth package and contains the User model.
- We have imported the project’s settings and we have added an author field to the Post model. This 
field defines a many-to-one relationship with the default user model, meaning that each post is written 
by a user, and a user can write any number of posts. For this field, Django will create a foreign key in 
the database using the primary key of the related model.
The on_delete parameter specifies the behavior to adopt when the referenced object is deleted. This 
is not specific to Django; it is a SQL standard. Using CASCADE, you specify that when the referenced 
user is deleted, the database will also delete all related blog posts. You can take a look at all the possible options at https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.
ForeignKey.on_delete.
We use related_name to specify the name of the reverse relationship, from User to Post. This will 
allow us to access related objects easily from a user object by using the user.blog_posts notation. 
We will learn more about this later.
Django comes with different types of fields that you can use to define your models. You can find all 
field types at https://docs.djangoproject.com/en/5.0/ref/models/fields/.
The Post model is now complete, and we can now synchronize it to the database.

💡A migration specifies dependencies on other migrations and operations to perform in the database to synchronize it with model changes.
- after running the makemigrations command to migrate the models to the sqlDB, it creates a file in the migrations directory containing the SQL statements to create the database table for the model defined in the models.py and the definition of the database indsx for the publish field, we can also use the sqlmigrate command to take a look at the SQL code that django will execute in the database to create the table for the model. it takes the migration names and returns their SQL wuthout executing it.
>> python manage.py sqlmigrate myblogsite 0001

CREATING AN ADMIN SITE FOR MODELS
💡 - Now that the Post model is in sync with the database, we can create a simple administration site to 
manage blog posts.
Django comes with a built-in administration interface that is very useful for editing content. The 
Django site is built dynamically by reading the model metadata and providing a production-ready 
interface for editing content. You can use it out of the box, configuring how you want your models to 
be displayed in it.
The django.contrib.admin application is already included in the INSTALLED_APPS setting, so you 
don’t need to add it.
- creating a superuser
>> python manage.py createsuperuser
ADDING MODELS TO THE ADMIN SITE
- When you register a model in the Django administration site, you get a user-friendly interface generated by introspecting your models that allows you to list, edit, create, and delete objects in a simple way.
- rather than using the admin.register(<model>)
we can use a decorator and a class that inherits from (admin.ModelAdmin) with attributes that we can define to customize how the admin app looks like with feilds from our model.

ADDING FACET COUNTS TO FILTERS
Django 5.0 introduces facet filters to the administration site, showcasing facet counts. These counts indicate the number of objects corresponding to each specific filter, making it easier to identify matching objects in the admin changelist view.
LEARM MORE: You can find more information about the Django administration site at https://docs.djangoproject.com/en/5.0/ref/contrib/admin/

💪🏼 Working with QuerySets and managers

Now that we have a fully functional administration site to manage blog posts, it is a good time to learn 
how to read and write content to the database programmatically.
The Django object-relational mapper (ORM) is a powerful database abstraction API that lets you 
create, retrieve, update, and delete objects easily. An ORM allows you to generate SQL queries using 
the object-oriented paradigm of Python. You can think of it as a way to interact with your database in 
a Pythonic fashion instead of writing raw SQL queries.
The ORM maps your models to database tables and provides you with a simple Pythonic interface to 
interact with your database. The ORM generates SQL queries and maps the results to model objects. 
The Django ORM is compatible with MySQL, PostgreSQL, SQLite, Oracle, and MariaDB.
Remember that you can define the database of your project in the DATABASES setting of your project’s 
settings.py file. Django can work with multiple databases at a time, and you can program database 
routers to create custom data routing schemes.
Once you have created your data models, Django gives you a free API to interact with them. You can 
find the model API reference of the official documentation at https://docs.djangoproject.com/
en/5.0/ref/models/.
The Django ORM is based on QuerySets. A QuerySet is a collection of database queries to retrieve objects from your database. You can apply filters to QuerySets to narrow down the query results based 
on given parameters. The QuerySet equates to a SELECT SQL statement and the filters are limiting SQL clauses such as WHERE or LIMIT.  
-  >>> user = User.objects.get(username="prospa")
The get() method allows us to retrieve a single object from the database. This method executes a 
SELECT SQL statement behind the scenes. Note that this method expects a result that matches the 
query. If no results are returned by the database, this method will raise a DoesNotExist exception, 
and if the database returns more than one result, it will raise a MultipleObjectsReturned exception. 
Both exceptions are attributes of the model class that the query is being performed on
- >>> post = Post(title='AnotherPost', slug='anotherslug', body='another post body', author=User)
This object is in memory and not persisted to the database; we created a Python object that can be 
used during runtime but is not saved into the database.
- >>> post.save()
This action performs an INSERT SQL statement behind the scenes.

💡WE CREATED AN OBJECT IN MEMORY FIRST AND PERSISTED IT TO DATABASE, HOWEVER WE CAN CREATE AN OBJECT AND PERSIST TO DATABASE IN A SINGLE OPERATION USING THE CREATE() METHOD AS FOLLOWS
- >>> Post.objects.create(title='One more post',
                        slug='another slug',
                        body='another post body',
                        author=user)

- In certain situations, you might need to fetch an object from the database or create it if it’s absent. 
The get_or_create() method facilitates this by either retrieving an object or creating it if not found. 
This method returns a tuple with the object retrieved and a Boolean indicating whether a new object 
was created. The following code attempts to retrieve a User object with the username user2, and if it 
doesn’t exist, it will create one:
- >>> user, created = User.objects.get_or_create(username='admin2')

💡 performing update:
note that changes made to the model opject are not persisted to the database until the save() method is called. the save() method in this context performs an UPDATE SQL statement under the hood
- >>> post.title('New Title')
- >>> post.save()
💡 retrieving objects
we can retrieve a single object using the get() method, we accessed the object using the Post.object.get(). Each django model has at least one manager and the default manager is called objects. You get a QuerySet using model manager. to retrieve all objects from a table we use the all() method on the default object manager thus
- >>> all_post = Post.objects.all()
Note that this QuerySet has not been executed yet. Django QuerySets are lazy, which means they are only evaluated when they 
are forced to. This behavior makes QuerySets very efficient. If you don’t assign the QuerySet to a variable but, instead, write it directly on the Python shell, the SQL statement of the QuerySet is executed 
because you are forcing it to generate output:
- >>> Post.objects.all()
💡 Filter Objects
To filter a QuerySet, you can use the filter() method of the manager. This method allows you to 
specify the content of a SQL WHERE clause by using field lookups.
- >>> post = Post.objects.filter(title="New Title")
- >>> print(post.query)
The generated WHERE clause performs an exact match on the title column. The ORDER BY clause 
specifies the default order defined in the ordering attribute of the Post model’s Meta options since 
we haven’t provided any specific ordering in the QuerySet. You will learn about ordering in a bit. Note 
that the query attribute is not part of the QuerySet public API.

💡 using field lookups
The QuerySet interface 
provides you with multiple lookup types. Two underscores are used to define the lookup type, with 
the format field__lookup. For example, the following lookup produces an exact match:
>>> Post.objects.filter(id__exact=1)
when no specific lookup type is provided the type defaults to exact. so this below is same as the previous above
>>> Post.objects.filter(id=1)
- iexact = generates a case-sensitive lookup with iexact
>>> Post.objects.filter(title__iexact='Dango containers")
- contains = the contains lookup translates to a SQL lookup using the LIKE operator
>>> Post.objects.filter(title__contains="Containers")
a case sensitive version is also available using icontains
>> Post.objects.filter(title__icontains="Django")
- id__in = retrieves post using a given iterable(a list, tuple, or another QuerySet object)
- gt or lt or lte = greaterthan, lessthan, lessthanorequal lookup. the equivalent SQL clause for this is WHERE ID > 3, < 3, <= 3
>>> Post.objects.filter(id__gt=3), Post.objects.filter(id__lt=3), Post.objects.filter(id__lte=3)
- startswith, endswith or case sensitive istartswith, iendswith
>> Post.objects.filter(title__iendswith="Title"), (.... title__startswith="Docker")
- date = can be performed using the several filters but first <from datetime import date>
>>> Post.objects.filter(publish__year=2025)
>>> Post.objects.filter(publish__date=date(2024, 1, 31))
>>> Post.objects.filter(publish__month=1)
>>> Post.objects.filter(publish__day=1)
>>> Post.objects.filter(publish__date__gt=date(2024, 1, 1))
- lookup related fields, use two underscores like this
>>> Post.objects.filter(author__username="prospa")
>>> Post.objects.filter(publish__year=2024, author__username='admin') #shows how to combine filters

NOTE: The result of a filtered QueySet is another QuerySet object. allowing me the ability to chain QuerySets together. so we can build an equivalent QuerySet of the previous last example like this
>>> Post.objects.filter(publish__year=2025)\
>>>             .filter(author__username='admin')
- ordering objects = the default ordering option is already defined in the models Meta, but we can overide that usinf the order_by() method of the manager for example
>>> Post.objects.order_by('title')
>>> Post.objects.order_by('-title') #ascending order is default, so we use negative sign to imply descending
>>> Post.objects.order_by('author', 'title') #order by multiple fields
>>> Post.objects.order_by('?') #order by random
>>> Post.objects.all()[:5] #limit the QuerySet to a certain numner of results
>>> Post.objects.order_by('?')[0] #retrieve objects of post in random order

- counting objects - the count() method counts the total number of objects matching the QuerySet and returns an integer
>>> Post.objects.filter(id__lt=3).count()
2
- checking for existing objects
usign the exist() method, we check for the existence of a resilt from a QuerySet. it returns a Boolean
>>> Post.objects.filter(title__startswith='Why').exists()

- deleting an object
we can do this by using the delete()method from an object instance
>>> post = Post.objects.get(id=1)
>>> post.delete()

🔥 Complex lookups with Q objects
Field lookups using filter() are joined with a SQL AND operator. For example, filter(field1='foo ', 
field2='bar') will retrieve objects where field1 is foo and field2 is bar. If you need to build more 
complex queries, such as queries with OR statements, you can use Q objects.
A Q object allows you to encapsulate a collection of field lookups. You can compose statements by 
combining Q objects with the & (and), | (or), and ^ (xor) operators. in this case we use | operator to build an OR operator
>>> from django.db.models import Q
>>> starts_who = Q(title__istartswith='who')
>>> starts_why = Q(title__istartswith='why')
>>> Post.objects.filter(starts_who | starts_why)
💪🏼 When QuerySets are evaluated
Creating a QuerySet doesn’t involve any database activity until it is evaluated. QuerySets will usually 
return another unevaluated QuerySet. You can concatenate as many filters as you like to a QuerySet, 
and you will not hit the database until the QuerySet is evaluated. When a QuerySet is evaluated, it 
translates into a SQL query to the database.
QuerySets are only evaluated in the following cases:
• The first time you iterate over them
• When you slice them, for instance, Post.objects.all()[:3]
• When you pickle or cache them
• When you call repr() or len() on them
• When you explicitly call list() on them
• When you test them in a statement, such as bool(), or, and, or if
The QuerySet API reference is located at https://docs.djangoproject.com/en/5.0/ref/models/
querysets/.
You can read more about making queries with the Django ORM at https://docs.djangoproject.com/

en/5.0/topics/db/queries/.
😁 creating model managers
- the default manager for every model is the object manager. it retrieves all the objects in the database. however we can define custom managers for models.
- two ways to add or customize managers for your models, we can add extra manager method to an existing manager or create a new manager by modifying the initial QuerySet that the manager returns. The first method provides me with a QuerySet notation like Post.my_manager.all()
- the second method here, is what we have used in this example, that will allow us to retreive posts using the notation Post.published.all()
💪🏼 Building List with detailed view
A Django view is just a Python function that receives a web request and returns a web response. All 
the logic to return the desired response goes inside the view.
First, you will create your application views, then you will define a URL pattern for each view, and 
finally, you will create HTML templates to render the data generated by the views. Each view will 
render a template, passing variables to it, and will return an HTTP response with the rendered output.
- The render() shortcut takes the request context into account, so any variable set by the template 
context processors is accessible by the given template. Template context processors are just callables 
that set variables into the context. 
❤️ defining the url patterns
URL patterns allow you to map URLs to views. A URL pattern is composed of a string pattern, a view, 
and, optionally, a name that allows you to name the URL project-wide. Django runs through each URL 
pattern and stops at the first one that matches the requested URL. Then, Django imports the view 
of the matching URL pattern and executes it, passing an instance of the HttpRequest class and the 
keyword or positional arguments.
In the preceding code, you define an application namespace with the app_name variable. This allows 
you to organize URLs by application and use the name when referring to them. You define two different 
patterns using the path() function. The first URL pattern doesn’t take any arguments and is mapped 
to the post_list view. The second pattern is mapped to the post_detail view and takes only one 
argument id, which matches an integer, set by the path converter int.
You use angle brackets to capture the values from the URL. Any value specified in the URL pattern as 
<parameter> is captured as a string. You use path converters, such as <int:year>, to specifically match 
and return an integer. For example <slug:post> would specifically match a slug (a string that can only 
contain letters, numbers, underscores, or hyphens). You can see all the path converters provided by 
Django at https://docs.djangoproject.com/en/5.0/topics/http/urls/#path-converters.
If using path() and converters isn’t sufficient for you, you can use re_path() instead to define complex 
URL patterns with Python regular expressions. You can learn more about defining URL patterns with 
regular expressions at https://docs.djangoproject.com/en/5.0/ref/urls/#django.urls.re_path. 
If you haven’t worked with regular expressions before, you might want to take a look at Regular Expression HOWTO, located at https://docs.python.org/3/howto/regex.html, first.
next, we include the URL patterns of the blog application on the main URL patterns of the project.
The new URL pattern defined with include refers to the URL patterns defined in the blog application 
so that they are included under the blog/ path. You include these patterns under the namespace blog. 
Namespaces have to be unique across your entire project. Later, you will refer to your blog URLs easily 
by using the namespace followed by a colon and the URL name, for example, blog:post_list and 
blog:post_detail. You can learn more about URL namespaces at https://docs.djangoproject.
com/en/5.0/topics/http/urls/#url-namespaces.
😍 creating templates for the views
Templates define how the data is displayed; 
they are usually written in HTML in combination with the Django template language. You can find 
more information about the Django template language at https://docs.djangoproject.com/en/5.0/
ref/templates/language/.
Django has a powerful template language that allows you to specify how data is displayed. It is based 
on template tags, template variables, and template filters:
• Template tags control the rendering of the template and look like this: {% tag %}.
• Template variables get replaced with values when the template is rendered and look like this: 
{{ variable }}.
• Template filters allow you to modify variables for display and look like this: {{ variable|filter 
}}.
You can see all the built-in template tags and filters at https://docs.djangoproject.com/en/5.0/
ref/templates/builtins/

DJANGO MANAGEMENT COMMANDS USED IN THIS PROJECT 
To create the file structure for a new Django project named mysite, we used the following command:
>> django-admin startproject mysite
To create the file structure for a new Django application named blog:
>> python manage.py startapp blog
To apply all database migrations:
>> python manage.py migrate
To create migrations for the models of the blog application:
>> python manage.py makemigrations blog
To view the SQL statements that will be executed with the first migration of the blog application:
>> python manage.py sqlmigrate blog 0001
To run the Django development server:
>> python manage.py runserver
To run the development server specifying host/port and settings file:
>> python manage.py runserver 127.0.0.1:8001 --settings=mysite.settings
To run the Django shell:
>> python manage.py shell
To create a superuser using the Django authentication framework:
>> python manage.py createsuperuser
For the full list of available management commands, check out https://docs.djangoproject.com/
en/5.0/ref/django-admin/.

STUDY MORE HERE 
Django URL dispatcher: https://docs.djangoproject.com/en/5.0/topics/http/urls/
• Django template language: https://docs.djangoproject.com/en/5.0/ref/templates/
language/
• Built-in template tags and filters: https://docs.djangoproject.com/en/5.0/ref/templates/
builtins/
• Django management commands: https://docs.djangoproject.com/en/5.0/ref/djangoadmin/

chapter 2
- USING CANONICAL URLS
for a site where different pages will display a particular post, a canonical url is used as the single main URL that displays the master page for all the post. Think of it like on a blog where u have all the post on a particular page, then on sunbsequent pages we can still see some of the posts. it is the most Representative page for specific content. it allows us to specify the URL for the master copy of a particular post, or page it references. Django allows us to use the get_absolute_url() method in the models to return the canonical URL for the object. django provides URL resolvers that allow me to build URLS dynamically using their names and any required parameters. in this case we use the reverse() function of the django.urls module. This function will build the URL dynamically using the URL name defined in the URL patterns. Building an SEO friendly URL means giving the urls to my views an identity that makes it unique anytime a request for that views is made, so in our example we first defined a canonical URL for the post_list view by using the get_absolute_url in the models.py file
- to add SEO friendly urls we made some edits to the urlpatterns for the post_details, using some path converters: The int path converter is used for the year, month, and day parameters, whereas the slug path converter is used for the post parameter. You learned about path converters in the previous chapter. You 
can see all path converters provided by Django at https://docs.djangoproject.com/en/5.0/topics/
http/urls/#path-converters.

- ADDING PAGINATION
Django has a built-in pagination class that allows you to manage paginated data easily. You can define 
the number of objects you want to be returned per page and you can retrieve the posts that correspond 
to the page requested by the user.
in the views.py this are the steps we took
1. We instantiate the Paginator class with the number of objects to return per page. We will 
display three posts per page.
2. We retrieve the page GET HTTP parameter and store it in the page_number variable. This parameter contains the requested page number. If the page parameter is not in the GET parameters of the request, we use the default value 1 to load the first page of results.
3. We obtain the objects for the desired page by calling the page() method of Paginator. This 
method returns a Page object that we store in the posts variable.
4. We pass the posts object to the template.

USING CLASS BASED VIEWS 
Class-based views are an alternative way to implement views as Python objects instead of functions. Since a view is a function that takes a web request and returns a web response, you can also define your views as class methods. Django provides base view classes that you can use to implement your 
own views. All of them inherit from the View class, which handles HTTP method dispatching and 
other common functionalities.
WHY USE CLASS BASED VIEWS
Class-based views offer some advantages over function-based views that are useful for specific use 
cases. Class-based views allow you to:
• Organize code related to HTTP methods, such as GET, POST, or PUT, in separate methods, instead 
of using conditional branching
• Use multiple inheritance to create reusable view classes (also known as mixins)

CREATING FORMS IN DJANGO
- DJANGO has a built-in forms framework that allows for the creation forms easily. The framework makes it simple to define the fields of the form, specify how they have to be displayed and indicate how they have to validate input data. also offers a flexible way to render forms in the HTML and handle data.
DJANGO has two base classes to build forms:
- Form: allows for building standard forms by defining fields and validations.
- ModelForm: this allows for building forms tied to model instances. It provides all the functionalities of the base Form class